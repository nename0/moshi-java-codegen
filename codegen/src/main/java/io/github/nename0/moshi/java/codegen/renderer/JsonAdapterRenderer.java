/*
 * Copyright (C) 2015 BlueLine Labs
 *
 * Original File Name: ObjectMapperInjector.java
 * From: https://git.io/JvS6l
 *
 * Modifications 2020
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.github.nename0.moshi.java.codegen.renderer;

import com.squareup.javapoet.*;
import com.squareup.moshi.*;
import io.github.nename0.moshi.java.codegen.JsonClassHolder;
import io.github.nename0.moshi.java.codegen.JsonFieldHolder;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;
import java.io.IOException;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.util.*;
import java.util.stream.Collectors;

public class JsonAdapterRenderer {

    private final JsonClassHolder classHolder;

    public JsonAdapterRenderer(JsonClassHolder classHolder) {
        this.classHolder = classHolder;
    }

    public void writeTo(Filer filer) throws IOException {
        TypeSpec typeSpec = getTypeSpec().toBuilder()
                .addOriginatingElement(classHolder.originatingElement)
                .build();
        JavaFile javaFile = JavaFile.builder(classHolder.packageName, typeSpec)
                .addFileComment("Code generated by moshi-java-codegen. Do not edit.")
                .build();
        javaFile.writeTo(filer);
    }

    private TypeSpec getTypeSpec() {
        TypeSpec.Builder builder = TypeSpec.classBuilder(classHolder.adapterClassName).addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addTypeVariables(classHolder.typeVariables);

        // we are loaded dynamically via Class.forName() so we are not unused
        builder.addAnnotation(AnnotationSpec.builder(SuppressWarnings.class).addMember("value", "\"unused\"").build());

        builder.superclass(ParameterizedTypeName.get(ClassName.get(JsonAdapter.class), classHolder.jsonClassTypeName));

        CodeBlock fieldNames = classHolder.fieldMap.values().stream()
                .map(field -> CodeBlock.of("$S", field.jsonName))
                .collect(CodeBlock.joining(",$W"));
        FieldSpec readerOptions = FieldSpec.builder(JsonReader.Options.class, "OPTIONS")
                .addModifiers(Modifier.PRIVATE, Modifier.FINAL, Modifier.STATIC)
                .initializer("$T.of($L)", JsonReader.Options.class, fieldNames)
                .build();
        builder.addField(readerOptions);

        ParameterSpec moshiConstructorParam = ParameterSpec.builder(Moshi.class, "moshi").build();

        DelegateAdapterFieldRenderer adapterFieldRenderer = new DelegateAdapterFieldRenderer(classHolder, moshiConstructorParam, builder);
        adapterFieldRenderer.addAdapterFields();

        MethodSpec.Builder constructorBuilder = MethodSpec.constructorBuilder().addModifiers(Modifier.PUBLIC);

        constructorBuilder.addParameter(moshiConstructorParam);

        List<String> typeVars = builder.typeVariables.stream().map(t -> t.name).collect(Collectors.toList());
        int typeVarsCount = typeVars.size();
        ParameterSpec types = ParameterSpec.builder(Type[].class, "types").build();
        if (typeVarsCount > 0) {
            constructorBuilder.addParameter(types);

            CodeBlock error = CodeBlock.of("\"TypeVariable mismatch: Expecting " + typeVarsCount + " type(s) for generic type variables " +
                    typeVars + ", but received \" + $N.length", types);
            constructorBuilder.beginControlFlow("if ($N.length != $L)", types, typeVarsCount)
                    .addStatement("throw new $T($L)", IllegalArgumentException.class, error)
                    .endControlFlow();
        }
        TypeRenderer typeRenderer = new TypeRenderer(types, classHolder.typeVariables);

        adapterFieldRenderer.addAdapterInitializers(constructorBuilder, typeRenderer);

        builder.addMethod(constructorBuilder.build());

        builder.addMethod(getFromJsonMethod(readerOptions));
        builder.addMethod(getToJsonMethod());
        return builder.build();
    }

    private MethodSpec getFromJsonMethod(FieldSpec readerOptions) {

        MethodSpec.Builder builder = MethodSpec.methodBuilder("fromJson")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .returns(classHolder.jsonClassTypeName)
                .addParameter(JsonReader.class, "reader")
                .addException(IOException.class);

        builder.addStatement("$T instance = new $T()", classHolder.jsonClassTypeName, classHolder.jsonClassTypeName)
                .addStatement("reader.beginObject()")
                .beginControlFlow("while (reader.hasNext())")
                .addStatement("int index = reader.selectName($N)", readerOptions)
                .beginControlFlow("switch (index)")
                .addCode("case -1:\n$>")
                .addStatement("reader.skipName()")
                .addStatement("reader.skipValue()")
                .addStatement("break$<");

        JsonFieldHolder[] fields = classHolder.fieldMap.values().toArray(new JsonFieldHolder[0]);
        for (int i = 0; i < fields.length; i++) {
            JsonFieldHolder field = fields[i];
            CodeBlock fieldValue = CodeBlock.of("$N.fromJson(reader)", field.adapterField);
            builder.addCode("case $L:\n$>", i);
            builder.addCode("(($T)instance).", field.accessorContainingClass);
            if (field.hasSetterAndGetter())
                builder.addStatement("$L($L)", field.setterMethod, fieldValue);
            else
                builder.addStatement("$L = $L", field.fieldName, fieldValue);
            builder.addStatement("break$<");
        }
        builder.endControlFlow()  // switch
                .endControlFlow() // while
                .addStatement("reader.endObject()")
                .addStatement("return instance");

        return builder.build();
    }

    private MethodSpec getToJsonMethod() {
        MethodSpec.Builder builder = MethodSpec.methodBuilder("toJson")
                .addAnnotation(Override.class)
                .addModifiers(Modifier.PUBLIC)
                .addParameter(JsonWriter.class, "writer")
                .addParameter(classHolder.jsonClassTypeName, "value")
                .addException(IOException.class);

        builder.addStatement("writer.beginObject()");

        for (JsonFieldHolder field : classHolder.fieldMap.values()) {
            CodeBlock.Builder fieldValue = CodeBlock.builder()
                    .add("(($T)value).", field.accessorContainingClass);
            if (field.hasSetterAndGetter())
                fieldValue.add("$L()", field.getterMethod);
            else
                fieldValue.add("$L", field.fieldName);
            builder.addStatement("writer.name($S)", field.jsonName)
                    .addStatement("$N.toJson(writer, $L)", field.adapterField, fieldValue.build());
        }

        builder.addStatement("writer.endObject()");

        return builder.build();
    }

}
